## 排序

### 初级排序算法

1.深入学习这些相对简单的算法的原因是：1.通过它们熟悉一些术语和简单的技巧；2.简单的算法有时比复杂的算法更加高效；3.有助于改进复杂算法的效率。

2.排序算法的类模板：

```js
class Sort {
  constructor(list) {
    this.list = list;
  }

  less(v, w) {
    return v < w;
  }

  exch(a, i, j) {
    const t = a[i];
    a[i] = a[j];
    a[j] = t;
  }

  show(a) {
    for (let i = 0; i < a.length; i++) {
      console.log('i', a[i]);
    }
  }

  isSorted(a) {
    for (let i = 0; i < (a.length - 1); i++) {
      if (a[i] > a[i + 1]) return false;
    }
    return true;
  }

  test(sortMethod) {
    this.list = [2, 7, 5, 2, 7, 4, 89, 3];
    console.log('before', this.list);
    sortMethod.call(this, this.list);
    console.log('after', this.list);
  }
}
```

3.选择排序：

```js
Sort.prototype.selectSort = function(a) {
  // 选择排序
  for (let i = 0; i < a.length; i++) {
    let min = i;

    for (let j = i + 1; j < a.length; j++) {
      if (this.less(a[j], a[min])) min = j;
    }

    this.exch(a, i, min);
  }
}
```

对于长度为 N 的数组，选择排序大约需要 (N^2)/2 次比较和 N 次交换。
选择排序有2个很鲜明的特点：1.运行时间和输入无关；2.数据移动是最少的。

4.插入排序

```js
Sort.prototype.insertSort = function(a) {
  // 插入排序
  for (let i = 0; i < a.length; i++) {
    for (let j = i; j >= 0; j--) {
      if (this.less(a[j], a[j - 1])) {
        this.exch(a, j, j - 1)
      } else {
        break;
      }
    }
  }
}
```

对于长度为 N 的数组，插入排序最多需要 (N^2)/2 次比较和 (N^2)/2 次交换，最少需要 N-1 次比较和 0 次交换。
选择排序有2个很鲜明的特点：1.非常适合部分有序或者小规模数组；2.是高级排序算法的中间过程。

5.我们用这些步骤来比较2个算法：1.实现并调试它们。2.分析它们的基本性质。3.对它们的相对性能作出猜想。4.用实验验证我们的猜想。

6.比较算法的性能：

```js
Sort.prototype.sortCompare = function(methodA, methodB) {
  let n = 800;
  let testArr = [];

  for (let i = 0; i < n; i++) {
    let arr = [];
    for (let j = 0; j < n; j++) {
      arr.push(Math.floor(Math.random()*1000));
    }
    testArr.push(arr);
  }

  console.time('第一个耗时');
  testArr.forEach((item) => {
    methodA.call(this, item.slice());
  });
  console.timeEnd('第一个耗时');

  console.time('第二个耗时');
  testArr.forEach((item) => {
    methodB.call(this, item.slice());
  });
  console.timeEnd('第二个耗时');
}
```

7.希尔排序：

```js
Sort.prototype.shellSort = function(a) {
  // 希尔排序
  let h = 1;
  const N = a.length;

  while(h < Math.floor(N / 3))  h = 3 * h + 1;

  while(h > 0) {
    for (let i = h; i < N; i += 1) {
      for (let j = i; j >= h; j -= h) {
        if (this.less(a[j], a[j - h])) {
          this.exch(a, j, j - h);
        } else {
          break;
        }
      }
    }

    h = Math.floor(h / 3);
  }
}
```

8.原地归并的抽象方法：

```js
class MergeSort extends Sort {
  constructor(list) {
    super(list);
    this.aux = new Array(list.length);
  }

  merge(a, lo, mid, hi) {
    // 将[lo, mid]和[mid + 1, hi]进行归并
    let i = lo;
    let j = mid + 1;

    for (let k = lo; k < hi; k++) {
      aux[k] = a[k];
    }

    let h = lo;
    while (h <= hi) {
      if (i > mid) a[h++] = aux[j++];
      else if (j > hi) a[h++] = aux[i++];
      else if (aux[i] < aux[j]) a[h++] = aux[i++];
      else a[h++] = aux[j++];
    }
  }
}
```
