## 排序

### 初级排序算法

1.深入学习这些相对简单的算法的原因是：1.通过它们熟悉一些术语和简单的技巧；2.简单的算法有时比复杂的算法更加高效；3.有助于改进复杂算法的效率。

2.排序算法的类模板：

```js
class Sort {
  constructor(list) {
    this.list = list;
  }

  less(v, w) {
    return v < w;
  }

  exch(a, i, j) {
    const t = a[i];
    a[i] = a[j];
    a[j] = t;
  }

  show(a) {
    for (let i = 0; i < a.length; i++) {
      console.log('i', a[i]);
    }
  }

  isSorted(a) {
    for (let i = 0; i < (a.length - 1); i++) {
      if (a[i] > a[i + 1]) return false;
    }
    return true;
  }

  test(sortMethod) {
    this.list = [2, 7, 5, 2, 7, 4, 89, 3];
    console.log('before', this.list);
    sortMethod.call(this, this.list);
    console.log('after', this.list);
  }
}
```

3.选择排序：

```js
Sort.prototype.selectSort = function(a) {
  // 选择排序
  for (let i = 0; i < a.length; i++) {
    let min = i;

    for (let j = i + 1; j < a.length; j++) {
      if (this.less(a[j], a[min])) min = j;
    }

    this.exch(a, i, min);
  }
}
```

对于长度为 N 的数组，选择排序大约需要 (N^2)/2 次比较和 N 次交换。
选择排序有2个很鲜明的特点：1.运行时间和输入无关；2.数据移动是最少的。

4.插入排序

```js
Sort.prototype.insertSort = function(a) {
  // 插入排序
  for (let i = 0; i < a.length; i++) {
    for (let j = i; j >= 0; j--) {
      if (this.less(a[j], a[j - 1])) {
        this.exch(a, j, j - 1)
      } else {
        break;
      }
    }
  }
}
```

对于长度为 N 的数组，插入排序最多需要 (N^2)/2 次比较和 (N^2)/2 次交换，最少需要 N-1 次比较和 0 次交换。
选择排序有2个很鲜明的特点：1.非常适合部分有序或者小规模数组；2.是高级排序算法的中间过程。

5.我们用这些步骤来比较2个算法：1.实现并调试它们。2.分析它们的基本性质。3.对它们的相对性能作出猜想。4.用实验验证我们的猜想。

6.比较算法的性能：

```js
Sort.prototype.sortCompare = function(methodA, methodB) {

}
```
